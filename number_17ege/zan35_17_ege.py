with open('17_25356 (1).txt') as f:
    sp = list(map(int, f)) #чтобы получить список чисел

count, max_s = 0, float('-inf') #максимум инициализируем минимальным значением, а минимум - максимальным
max_30 = max(i for i in sp if abs(i) % 100 == 30) #все остатки от деления берем от модуля числа, так как остатки от отрицательных чисел в математике берутся иначе


def check_four(x):
    return 1000 <= abs(x) <= 9999

#1 способ. по индексам
for i in range(len(sp) - 2): #чтобы не было ошибки - отсекаем лишние индексы
    x, y, z = sp[i:i+3] #sp[i], sp[i + 1], sp[i + 2] 
    '''
    1 способ, как обработать условие с 4-значностью.
    Этот способ является наименее предпочтительным, так как
    могут встретиться условия, при которых требуется наличие
    РОВНО одного/двух чисел, которые соотвествуют условию

    if not(1000 <= abs(x) <= 9999) and not(1000 <= abs(y) <= 9999) \
        and not(1000 <= abs(z) <= 9999):
    '''

    '''
    2 способ, как обработать условие с 4-значностью.

    Создание функции.

    if len(list(filter(check_four, (x, y, z)))) == 0:
    
    У этого способа есть существенный минус - знание функции filter.

    '''
    '''
    3 способ, как обработать условие с 4-значностью.

    if sum(1 for i in (x, y, z) if 1000 <= abs(i) <= 9999) == 0:
    
    При помощие встроенной функции sum. При помощи этого способа
    можно точно посчитать, сколько условие должно быть истинных или ложных
    '''
    '''
    4 способ, как обработать условие с 4-значностью.

    if all(not(1000 <= abs(i) <= 9999) for i in (x, y, z)):
    
    Способ подходит, если ВСЕ числа не должны/должны подходить какому-то условию
    ИЛИ
    if not any(not(1000 <= abs(i) <= 9999) for i in (x, y, z)):
    '''
    '''
    На самом деле эти способы универсальны для любого условия, но
    если условие слишком сложное, то подойдет только 2 способ.
    '''
    if sum(1 for i in (x, y, z) if 1000 <= abs(i) <= 9999) == 0 and (x + y + z) > max_30:
        count += 1
        max_s = max(x + y + z, max_s)
print(count, max_s)
    
'''
a = [1, 2, 3, 4]
b = [5, 6, 7, 8]

list(zip(a, b)) = [(1, 5), (2, 6), (3, 7), (4, 8)]

a = [1, 2, 3, 4]
a[1:] = [2, 3, 4]

list(zip(a, a[1:])) = [(1, 2), (2, 3), (3, 4)]
'''
count = 0

for x, y, z in zip(sp, sp[1:], sp[2:]):
    if sum(1 for i in (x, y, z) if 1000 <= abs(i) <= 9999) == 0 and (x + y + z) > max_30:
        count += 1
        max_s = max(x + y + z, max_s)
print(count, max_s)

with open('17_23952.txt') as f:
    sp = list(map(int, f))

count, summa = 0, 0

max_93 = max(i for i in sp if abs(i) % 100 == 93)

for x, y in zip(sp, sp[1:]):
    '''
    Ровно один из двух.

    Исключающее ИЛИ. Дает истину тогда и только тогда, когда у операндов разные логические значение. Обозначается !=
    '''
    if (x > max_93) != (y > max_93): #ставим в скобки, чтобы сначала проверили с max_93, а потом проверилось условие
        if str(x)[0] == '9' or str(y)[0] == '9':
            count += 1
            if x > max_93:
                summa += x
            elif y > max_93:
                summa += y

print(count, summa)

with open('17_23949.txt') as f:
    sp = list(map(int, f))

count, summa = 0, 0

for x, y, z in zip(sp, sp[1:], sp[2:]):
    if sum(1 for i in (x, y, z) if str(i)[0] == str(i)[-1]) == 1 \
        and sum(1 for i in (x, y, z) if 10 ** 4 <= abs(i) < 10 ** 5 and abs(i) // 1000 % 10 == 7) == 2:
        count += 1
        summa += max(x, y, z)

print(count, summa)

